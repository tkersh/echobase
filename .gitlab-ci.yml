# GitLab CI/CD Pipeline for Echobase
# Designed for devlocal machine deployment with GitLab Runner (Docker Executor)

# Stages define the order of execution
stages:
  - validate       # Code validation and linting
  - build          # Build Docker images
  - durable        # Setup durable infrastructure (databases)
  - deploy-green   # Deploy to green environment for testing
  - test           # Run all tests (including tests against green)
  - deploy         # Deploy to local environment
  - teardown       # Manual teardown/cleanup stage

# Global variables
variables:
  # Docker Configuration
  DOCKER_HOST: unix:///var/run/docker.sock
  COMPOSE_PROJECT_NAME: echobase
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

  # Terraform Configuration
  TF_IN_AUTOMATION: "true"
  TF_INPUT: "false"

  # Test Configuration
  PLAYWRIGHT_BROWSERS_PATH: "$CI_PROJECT_DIR/.cache/ms-playwright"

  # Deployment Configuration
  DEPLOYMENT_ENV: "local"

  # CI/CD Flags
  GIT_STRATEGY: clone
  GIT_DEPTH: "1"

  # Network Configuration
  LOCALHOST_IP: "127.0.0.1"

  # Health Check Configuration
  HEALTH_CHECK_INTERVAL: "3"        # Seconds between health checks
  MARIADB_TIMEOUT: "120"            # MariaDB startup timeout in seconds
  LOCALSTACK_TIMEOUT: "150"         # LocalStack startup timeout in seconds
  API_GATEWAY_TIMEOUT: "120"        # API Gateway startup timeout in seconds
  FRONTEND_TIMEOUT: "90"            # Frontend startup timeout in seconds
  ORDER_PROCESSOR_TIMEOUT: "60"     # Order Processor startup timeout in seconds

  # Dev-Local Environment Ports (via start.sh)
  # These are used by docker-compose.override.yml
  DEV_LOCAL_API_PORT: "3001"
  DEV_LOCAL_FRONTEND_PORT: "3443"
  DEV_LOCAL_DB_PORT: "3306"
  DEV_LOCAL_LOCALSTACK_PORT: "4566"

  # Green Environment Ports (docker-compose.green.yml) - Staging
  # Can coexist with devlocal
  GREEN_API_PORT: "3101"
  GREEN_FRONTEND_PORT: "3543"
  GREEN_DB_PORT: "3406"
  GREEN_LOCALSTACK_PORT: "4666"

# Default settings for all jobs
default:
  artifacts:
    expire_in: 2 days
  image: docker:24
  tags:
    - docker-local  # Tag for your local GitLab runner with Docker executor
  before_script:
    - apk add --no-cache bash curl git docker-cli-compose nodejs npm openssl iproute2
  retry:
    max: 1
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Cache configuration for dependencies
.cache_node_modules: &cache_node_modules
  cache:
    key: ${CI_COMMIT_REF_SLUG}-node-modules
    paths:
      - .npm/
      - backend/api-gateway/node_modules/
      - backend/order-processor/node_modules/
      - frontend/node_modules/
      - e2e-tests/node_modules/
    policy: pull

# Common before_script patterns
.install_terraform: &install_terraform
  - echo "Installing Terraform..."
  - curl -LO https://releases.hashicorp.com/terraform/1.14.2/terraform_1.14.2_linux_amd64.zip
  - unzip -o terraform_1.14.2_linux_amd64.zip -d /usr/local/bin/
  - chmod +x /usr/local/bin/terraform
  - terraform --version

.setup_scripts: &setup_scripts
  - chmod +x scripts/*.sh

.terraform_job_setup: &terraform_job_setup
  before_script:
    - apk add --no-cache bash curl git docker-cli-compose nodejs npm openssl unzip
    - *install_terraform
    - *setup_scripts

# ============================================================================
# VALIDATE STAGE
# ============================================================================

validate:env-check:
  stage: validate
  script:
    - echo "Checking environment prerequisites..."
    - docker --version
    - docker compose version
    - node --version
    - npm --version
    - echo "Generating .env file for CI..."
    - ./generate-credentials.sh
    - echo "Verifying .env file was created..."
    - test -f .env || (echo "ERROR - .env file generation failed!" && exit 1)

    # Configure environment for CI with Docker network
    - echo "Configuring environment for CI..."
    - sed -i "s|CORS_ORIGIN=.*|CORS_ORIGIN=https://localhost:${GREEN_FRONTEND_PORT}|g" .env
    # REACT_APP_API_URL should be empty - frontend uses same-origin and nginx proxies to backend
    - sed -i "s|REACT_APP_API_URL=.*|REACT_APP_API_URL=|g" .env
    - sed -i 's|RATE_LIMIT_MAX_REQUESTS=.*|RATE_LIMIT_MAX_REQUESTS=100000|g' .env
    - sed -i 's|RATE_LIMIT_WINDOW_MS=.*|RATE_LIMIT_WINDOW_MS=900000|g' .env
    - echo "CI-specific configuration:"
    - grep -E "(CORS_ORIGIN|REACT_APP_API_URL|RATE_LIMIT)" .env

    - echo "Environment check passed!"
  artifacts:
    paths:
      - .env
      - mariadb/config/
    expire_in: 1 hour
  only:
    - branches
    - merge_requests

validate:terraform:
  stage: validate
  before_script:
    - apk add --no-cache bash curl git docker-cli-compose nodejs npm openssl unzip
    - *install_terraform
  script:
    - echo "Validating Terraform configuration..."
    - cd terraform
    - terraform init -backend=false
    - terraform validate
    - terraform fmt -check -recursive
    - echo "Terraform validation passed!"
  only:
    - branches
    - merge_requests

validate:compose:
  stage: validate
  variables:
    GIT_STRATEGY: clone
    GIT_CLEAN_FLAGS: -ffdx
  tags:
    - docker-local
  script:
    - echo "Validating Docker Compose configuration..."
    # Create minimal .env file for validation
    - |
      cat > .env <<EOF
      MYSQL_ROOT_PASSWORD=test
      MYSQL_DATABASE=test_db
      MYSQL_USER=testuser
      MYSQL_PASSWORD=testpass
      PORT=3001
      AWS_REGION=us-east-1
      AWS_ACCESS_KEY_ID=test
      AWS_SECRET_ACCESS_KEY=test
      SQS_ENDPOINT=http://localhost:4566
      SQS_QUEUE_URL=http://localhost:4566/queue/test
      DB_SECRET_NAME=test
      JWT_SECRET=test
      CORS_ORIGIN=http://localhost:3000
      RATE_LIMIT_WINDOW_MS=60000
      RATE_LIMIT_MAX_REQUESTS=100
      DB_HOST=localhost
      DB_PORT=3306
      DB_NAME=test_db
      POLL_INTERVAL=5000
      MAX_MESSAGES=10
      REACT_APP_API_URL=http://localhost:3001
      EOF
    - docker compose config > /dev/null
    - echo "Docker Compose configuration is valid!"
  only:
    - branches
    - merge_requests

# ============================================================================
# BUILD STAGE
# ============================================================================

build:dependencies:
  stage: build
  <<: *cache_node_modules
  cache:
    policy: pull-push
  script:
    - echo "Installing Node.js dependencies..."
    - npm config set cache $CI_PROJECT_DIR/.npm --global
    - |
      # Install dependencies for all components
      for component in backend/api-gateway backend/order-processor frontend e2e-tests; do
        echo "Installing dependencies for ${component}..."
        (cd "$component" && npm ci --prefer-offline --no-audit)
      done
    - echo "All dependencies installed successfully!"
  artifacts:
    paths:
      - backend/api-gateway/node_modules/
      - backend/order-processor/node_modules/
      - frontend/node_modules/
      - e2e-tests/node_modules/
    expire_in: 1 hour
  only:
    - branches
    - merge_requests

build:docker-images:
  stage: build
  tags:
    - docker-local
  before_script:
    - apk add --no-cache bash docker-cli-compose
    - *setup_scripts
    - docker info
  dependencies:
    - build:dependencies
    - validate:env-check
  needs:
    - build:dependencies
    - validate:env-check
  script:
    - echo "Building Docker images..."
    - source .env

    # Set build metadata for Docker images (using GitLab CI predefined variables)
    - export GIT_SHA=${CI_COMMIT_SHORT_SHA}
    - export BUILD_DATE=${CI_COMMIT_TIMESTAMP}
    - echo "Build metadata:"
    - echo "  GIT_SHA=${GIT_SHA}"
    - echo "  BUILD_DATE=${BUILD_DATE}"
    - echo "  CI_PIPELINE_ID=${CI_PIPELINE_ID}"

    # Clean up any stale BuildKit cache to avoid snapshot errors
    - echo "Cleaning BuildKit cache..."
    - docker builder prune -f --filter "until=24h" || true

    - echo "Building base image..."
    - docker build -t echobase-node-base:latest docker/base/

    # Build images without starting services (build args will be picked up from env vars)
    - docker compose build --parallel

    - echo "Docker images built successfully!"
    - docker images | grep echobase || echo "Images built"

    # Verify build metadata was included in images
    - scripts/verify-build-metadata.sh images

    # Images remain in Docker daemon for deploy:green to use (same runner, same daemon)
    - echo "Images built and ready in Docker daemon for deployment"
  only:
    - branches
    - merge_requests

# ============================================================================
# DURABLE INFRASTRUCTURE STAGE
# ============================================================================

durable:setup-ci:
  stage: durable
  tags:
    - docker-local
  before_script:
    - apk add --no-cache bash curl docker-cli-compose unzip
    - *install_terraform
    - *setup_scripts
  # NOTE: Durable infrastructure is independent of build stage
  # It can run in parallel with builds since it only sets up database & LocalStack
  # deploy:green will wait for both this and build:docker-images to complete
  dependencies:
    - validate:env-check
  needs:
    - validate:env-check
  script:
    - |
      echo "=========================================="
      echo "Setting up CI Durable Infrastructure"
      echo "=========================================="
      echo ""
      echo "This job is IDEMPOTENT:"
      echo "  - If database exists and is running: skips creation"
      echo "  - If database exists but stopped: starts it"
      echo "  - If database doesn't exist: creates it"
      echo ""
      echo "The CI database persists across pipeline runs for data continuity."
      echo "To rebuild: manually run 'teardown:durable-ci' job first"
      echo ""
      
      source .env
      echo "Configuring environment for CI..."
      sed -i 's|DB_HOST=.*|DB_HOST=echobase-ci-durable-mariadb|g' .env
      echo "DB_HOST=$(grep DB_HOST .env)"
      
      chmod +x durable/setup.sh durable/teardown.sh
      echo ""
      echo "Running durable infrastructure setup (idempotent)..."
      ./durable/setup.sh ci
      
      echo ""
      echo "Verifying durable infrastructure status..."
      docker ps --filter "name=echobase-ci-durable" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
      
      echo ""
      echo "Durable infrastructure ready for CI deployments"
  artifacts:
    paths:
      - .env
    expire_in: 1 hour
  only:
    - branches

# ============================================================================
# GREEN ENVIRONMENT TESTS (run against deployed green environment)
# ============================================================================

test:green-api-gateway:
  stage: test
  tags:
    - docker-local
  before_script:
    - apk add --no-cache bash curl git nodejs npm docker-cli-compose
    - *setup_scripts
  <<: *cache_node_modules
  dependencies:
    - build:dependencies
    - validate:env-check
  needs:
    - build:dependencies
    - validate:env-check
    - deploy:green
  script:
    - echo "Running all API Gateway tests (unit + security) against GREEN environment..."
    - source .env
    - echo "Checking green environment status..."
    - docker compose -p echobase-green ps
    - scripts/wait-for-services.sh echobase-green api-gateway
    - docker compose -p echobase-green exec -T api-gateway npm test -- --coverage --ci
    - mkdir -p backend/api-gateway/test-results
    - docker compose -p echobase-green cp api-gateway:/app/test-results/. backend/api-gateway/test-results/ || true
    - docker compose -p echobase-green cp api-gateway:/app/coverage/. backend/api-gateway/coverage/ || true
  artifacts:
    reports:
      junit: backend/api-gateway/test-results/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: backend/api-gateway/coverage/cobertura-coverage.xml
    paths:
      - backend/api-gateway/test-results/
      - backend/api-gateway/coverage/
    expire_in: 1 week
    when: always
  after_script:
    - docker compose -p echobase-green logs --tail=50 api-gateway || true
  only:
    - branches
    - merge_requests

test:green-e2e:
  stage: test
  # Use host Docker daemon to access containers from deploy:green
  tags:
    - docker-local  # Matches local runner tag
  before_script:
    - apk add --no-cache bash curl git docker-cli-compose
    - *setup_scripts
  dependencies:
    - build:dependencies
    - validate:env-check
  needs:
    - build:dependencies
    - validate:env-check
    - deploy:green
  script:
    - |
      set -e

      # Error trapping to identify where failures occur
      failure_message() {
        echo "ERROR: Script failed on line $1"
      }
      trap 'failure_message $LINENO' ERR
      
      echo "Running E2E tests against GREEN environment..."
      source .env

      echo "Retrieving database credentials from Secrets Manager..."
      SECRET_JSON=$(docker exec echobase-ci-durable-localstack awslocal secretsmanager get-secret-value \
        --secret-id echobase/database/credentials \
        --query SecretString \
        --output text)

      export DB_USER=$(echo "$SECRET_JSON" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)
      export DB_PASSWORD=$(echo "$SECRET_JSON" | grep -o '"password":"[^"]*"' | cut -d'"' -f4)
      export DB_NAME=$(echo "$SECRET_JSON" | grep -o '"dbname":"[^"]*"' | cut -d'"' -f4)

      echo "Database user: $DB_USER"
      echo "Database name: $DB_NAME"
      echo "Checking green environment status..."
      docker compose -p echobase-green ps
      scripts/wait-for-services.sh echobase-green api-gateway frontend

      echo "=== Verifying Build Metadata in Running Containers ==="
      scripts/verify-build-metadata.sh containers echobase-green || echo "WARNING: Build metadata verification failed (non-blocking)"

      echo "=== API Gateway Startup Logs (first 100 lines) ==="
      if API_GATEWAY_CONTAINER=$(scripts/get-container-name.sh echobase-green api-gateway); then
        timeout 30 docker logs "$API_GATEWAY_CONTAINER" 2>&1 | head -100 || echo "WARNING: Failed to get first 100 lines (timeout or error)"
        echo ""
        echo "=== API Gateway Recent Logs (last 50 lines) ==="
        timeout 30 docker logs "$API_GATEWAY_CONTAINER" --tail 50 2>&1 || echo "WARNING: Failed to get last 50 lines (timeout or error)"
        echo "=== Log collection completed ==="
      else
        echo "WARNING: Failed to get API Gateway container (see error details above)"
      fi
      
      echo "Running Playwright E2E tests inside the green network..."

      echo "Checking Docker networks..."
      docker network ls | grep green || echo "No green network found by name"

      # Use the exact network name from docker-compose.green.yml
      NETWORK_NAME="echobase-green-network"

      # Verify the network exists
      if ! docker network inspect "$NETWORK_NAME" >/dev/null 2>&1; then
        echo "ERROR: Network $NETWORK_NAME not found. Available networks:"
        docker network ls
        exit 1
      fi

      echo "Using network: $NETWORK_NAME"

      echo "Creating test container..."
      CONTAINER_ID=$(docker create \
        --network "$NETWORK_NAME" \
        -e CI=true \
        -e DB_HOST=echobase-ci-durable-mariadb \
        -e DB_PORT=3306 \
        -e DB_NAME=$DB_NAME \
        -e DB_USER=$DB_USER \
        -e DB_PASSWORD=$DB_PASSWORD \
        -e API_BASE_URL=https://echobase-green-api-gateway:3001 \
        -e BASE_URL=https://echobase-green-frontend:443 \
        -e AWS_REGION=us-east-1 \
        -e AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \
        -e AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY \
        -e SQS_ENDPOINT=http://echobase-green-localstack:4566 \
        -e NODE_TLS_REJECT_UNAUTHORIZED=0 \
        -w /work \
        mcr.microsoft.com/playwright:v1.56.0-noble \
        /bin/bash -c "npx playwright install chromium && npm test")

      if [ -z "$CONTAINER_ID" ]; then
        echo "ERROR: Failed to create container"
        exit 1
      fi

      echo "Container created: $CONTAINER_ID"

      echo "Connecting test container to durable CI network..."
      docker network connect echobase-ci-durable-network $CONTAINER_ID

      echo "Copying test files into container..."
      if ! docker cp e2e-tests/. $CONTAINER_ID:/work/; then
        echo "ERROR: Failed to copy test files"
        docker rm $CONTAINER_ID || true
        exit 1
      fi

      echo "Removing .env file (CI uses environment variables instead)..."
      docker exec $CONTAINER_ID rm -f /work/.env || echo "No .env file to remove"

      echo "Starting tests..."
      set +e
      docker start -a $CONTAINER_ID
      TEST_EXIT_CODE=$?
      set -e

      echo "Tests completed with exit code: $TEST_EXIT_CODE"

      echo "Copying test results back..."
      mkdir -p e2e-tests/playwright-report e2e-tests/test-results
      docker cp $CONTAINER_ID:/work/playwright-report/. e2e-tests/playwright-report/ 2>&1 || echo "No playwright-report directory found"
      docker cp $CONTAINER_ID:/work/test-results/. e2e-tests/test-results/ 2>&1 || echo "No test-results directory found"

      if [ $TEST_EXIT_CODE -ne 0 ]; then
        echo "ERROR: Tests failed with exit code: $TEST_EXIT_CODE"
        echo ""
        echo "=== Container logs (last 50 lines) ==="
        docker logs --tail=50 $CONTAINER_ID || true
        echo "=== API Gateway Logs (last 100 lines) ==="
        docker logs echobase-green-api-gateway --tail 100 2>&1 | grep -E "CSRF|CORS|403|ERROR|Rejected" || docker logs echobase-green-api-gateway --tail 100
        echo ""
        echo "=== Frontend Logs (last 50 lines) syzygy ==="
        docker logs echobase-green-frontend --tail 50 2>&1 || true
      else
        echo "✓ All E2E tests passed"
      fi

      echo "Removing container..."
      docker rm $CONTAINER_ID || true
      exit $TEST_EXIT_CODE

  artifacts:
    paths:
      - e2e-tests/playwright-report/
      - e2e-tests/test-results/
    reports:
      junit: e2e-tests/test-results/junit.xml
    expire_in: 1 week
    when: always
  after_script:
    - echo "=== Green environment service logs (last 100 lines) ==="
    - docker compose -p echobase-green logs --tail=100 || true
  only:
    - branches
    - merge_requests

# ============================================================================
# DEPLOY STAGE
# ============================================================================

# ============================================================================
# BLUE-GREEN DEPLOYMENT
# ============================================================================

deploy:green:
  stage: deploy-green
  # Use host Docker daemon for persistent containers
  # Requires GitLab runner with Docker socket access
  tags:
    - docker-local  # Matches local runner tag
  before_script:
    - apk add --no-cache bash curl git docker-cli-compose wget unzip
    - *install_terraform
    - *setup_scripts
  dependencies:
    - durable:setup-ci
  needs:
    - build:docker-images
    - durable:setup-ci
  script:
    - |
      echo "Deploying to GREEN environment..."
      source .env
      
      echo "Verifying durable infrastructure is running..."
      docker ps --filter "name=echobase-ci-durable" --format "{{.Names}}: {{.Status}}"

      echo "Cleaning up any existing green environment..."
      # The '|| true' ensures the pipeline doesn't fail if the green environment doesn't exist yet
      docker compose -f docker-compose.yml -f docker-compose.green.yml -p echobase-green down || true
      
      echo "Note: Database is managed separately in durable infrastructure"

      # Images are already in Docker daemon from build:docker-images (same runner)
      echo "Verifying images are available in Docker daemon..."
      docker images | grep echobase
      scripts/verify-build-metadata.sh images

      echo "Images ready for deployment (built in build:docker-images job)"
      
      echo "Starting green environment..."
      docker compose -f docker-compose.yml -f docker-compose.green.yml -p echobase-green up -d localstack
      
      scripts/wait-for-services.sh echobase-green localstack
      scripts/wait-for-endpoint.sh http://localhost:${GREEN_LOCALSTACK_PORT}/_localstack/health ${LOCALSTACK_TIMEOUT} "LocalStack (Green)"
      
      # Apply infrastructure changes (e.g., S3 buckets, queues) to LocalStack
      scripts/terraform-apply.sh http://localhost:${GREEN_LOCALSTACK_PORT}
      
      docker compose -f docker-compose.yml -f docker-compose.green.yml -p echobase-green up -d api-gateway frontend order-processor
      
      scripts/wait-for-services.sh echobase-green api-gateway frontend order-processor
      
      echo "Verifying green environment..."
      docker compose -p echobase-green ps
      
      echo ""
      echo "=== Port Mappings Check ==="
      # This command contains single quotes and a pipe, which is handled fine inside the literal block
      docker ps --format "table {{.Names}}\t{{.Ports}}" | grep -E "echobase-green|echobase-ci-durable|NAMES"
      
      echo "✓ Green environment deployed successfully!"
      echo "Green environment services are running on internal network:"
      # These final lines were causing validation errors due to the ':' and embedded single quotes
      echo "  - MariaDB (Durable): echobase-ci-durable-mariadb:3306"
      echo "  - LocalStack: echobase-green-localstack:4566"
      echo "  - API Gateway: echobase-green-api-gateway:3001"
      echo "  - Frontend: echobase-green-frontend:443"
      
      echo ""
      echo "Green environment ready for testing (containers will persist)"
      echo "Note: Database is in durable infrastructure and persists across deployments"
  environment:
    name: green-canary
    url: http://localhost:8081
    on_stop: teardown:green
  only:
    - branches

promote:green:
  stage: deploy
  needs:
    - deploy:green
  script:
    - echo "Promoting GREEN to production..."
    - chmod +x scripts/switch-environment.sh
    - ./scripts/switch-environment.sh green
    - echo "✓ Traffic switched to green environment"
    - echo "Production now points to:"
    - 'echo "  - Frontend: https://docker:${GREEN_FRONTEND_PORT} (via port 443)"'
    - 'echo "  - API: https://docker:${GREEN_API_PORT} (via /api)"'
    - echo ""
    - echo "Old blue environment still running on:"
    - 'echo "  - Direct access: http://localhost:8080"'
    - echo "Use 'teardown:blue' job to remove old environment"
  environment:
    name: production
    url: https://localhost
  when: manual
  only:
    - branches

rollback:to-blue:
  stage: deploy
  script:
    - echo "Rolling back to BLUE environment..."
    - chmod +x scripts/switch-environment.sh
    - ./scripts/switch-environment.sh blue
    - echo "✓ Traffic switched back to blue environment"
    - echo "You can now investigate or remove green environment"
  environment:
    name: production
    url: https://localhost
  when: manual
  only:
    - branches

# ============================================================================
# TEARDOWN STAGE
# ============================================================================

teardown:blue:
  stage: teardown
  <<: *terraform_job_setup
  script:
    - echo "Removing old BLUE environment..."
    - scripts/terraform-destroy.sh
    - docker compose -p echobase down
    - echo "✓ Blue environment removed"
  when: manual
  only:
    - branches

teardown:green:
  stage: teardown
  script:
    - |
      echo "Removing GREEN environment..."
      docker compose -f docker-compose.yml -f docker-compose.green.yml -p echobase-green down || true
      echo "Green environment removed"
      echo "Note: Durable CI infrastructure is still running. Use teardown:durable-ci to remove it."
  environment:
    name: green-canary
    action: stop
  when: manual
  only:
    - branches

teardown:durable-ci:
  stage: teardown
  before_script:
    - apk add --no-cache bash docker-cli-compose
    - *setup_scripts
  script:
    - |
      echo "WARNING: This will remove the CI durable infrastructure!"
      echo "This includes the CI database and all its data."
      chmod +x durable/teardown.sh
      ./durable/teardown.sh ci --volumes
      echo "CI durable infrastructure removed (including data)"
  when: manual
  only:
    - branches

teardown:devlocal:
  stage: teardown
  <<: *terraform_job_setup
  script:
    - echo "Cleaning up devlocal environment..."
    - echo "NOTE - This cleans the devlocal environment started with start.sh"
    - echo "       For green staging environment, use cleanup:green"
    - scripts/terraform-destroy.sh
    - docker compose down
    - echo "Dev-local cleanup complete!"
  environment:
    name: devlocal
    action: stop
  when: manual
  only:
    - branches

teardown:volumes:
  stage: teardown
  <<: *terraform_job_setup
  script:
    - echo "WARNING - This will remove all Docker volumes and data!"
    - scripts/terraform-destroy.sh
    - docker compose down -v
    - echo "All volumes removed!"
  when: manual
  only:
    - branches

# ============================================================================
# UTILITY JOBS
# ============================================================================

logs:view:
  stage: .post
  script:
    - echo "Fetching logs from running containers..."
    - docker compose ps
    - echo "=== API Gateway Logs ==="
    - docker compose logs --tail=50 api-gateway || true
    - echo "=== Order Processor Logs ==="
    - docker compose logs --tail=50 order-processor || true
    - echo "=== Frontend Logs ==="
    - docker compose logs --tail=50 frontend || true
    - echo "=== Localstack Logs ==="
    - docker compose logs --tail=50 localstack || true
  when: manual
  only:
    - branches

database:query:
  stage: .post
  tags:
    - docker-local
  script:
    - echo "Querying CI database for recent orders..."
    - source .env
    - docker exec echobase-ci-durable-mariadb mariadb -u $DB_USER -p$DB_PASSWORD $DB_NAME -e "SELECT id, customer_name, product_name, order_status, created_at FROM orders ORDER BY created_at DESC LIMIT 10;"
  when: manual
  only:
    - branches
